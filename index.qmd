---
title: "Simulation Challenge"
subtitle: "Generative Models and Monte Carlo Simulation"
format:
  html: default
execute:
  echo: false
  eval: true
---

1. **Expected Value Analysis:** What is the "expected value" of your account balance after 1 coin flip for the original game?

## The expected value of the account balance after 1 coin flip for the original game is $1000 * (0.5 * 1.5 + 0.5 * 0.6) = $1050. Therefore, the expected value is positive and $1050.

```{python}
#| label: q1-expected-value
#| echo: false

initial_balance = 1000
gain_rate = 0.5    # +50% on heads
loss_rate = 0.4    # -40% on tails

# Expected value after one flip:
# E[B1] = 0.5 * (B0 * 1.5) + 0.5 * (B0 * 0.6)
expected_value = initial_balance * (0.5 * (1 + gain_rate) + 0.5 * (1 - loss_rate))

print(f"Starting balance: ${initial_balance:,.0f}")
print(f"Expected value after one flip: ${expected_value:,.0f}")
```

2. **Expectation vs. Reality:** Is the expected value positive or negative? Do you expect your account to be worth more or less than $1,000 based on this result?

## The expected value is positive with a gain of $50. Therefore, I expect my account to be worth more than $1,000.

```{python}
#| label: q2-expectation-vs-reality
#| echo: false

initial_balance = 1000
gain_rate = 0.5   # +50% on heads
loss_rate = 0.4   # -40% on tails
p_heads = 0.5
p_tails = 0.5

balance_if_heads = initial_balance * (1 + gain_rate)
balance_if_tails = initial_balance * (1 - loss_rate)
expected_value = p_heads * balance_if_heads + p_tails * balance_if_tails

is_positive = expected_value > initial_balance

print(f"Expected value: ${expected_value:,.0f}")
print("Is expected value positive?", "Yes" if expected_value > initial_balance else "No")
print("Expected balance > $1,000?", "Yes" if is_positive else "No")
```

3. **Single Simulation:** Run one simulation showing the dynamics of your account balance over time. Make an object-oriented matplotlib OR ggplot2 plot showing your simulated account balance over time (i.e. as you age). Comment on the results, are you happy?

## Answer: Below is a single simulation of the original game (multiplicative: +50% on heads, -40% on tails) over 30 years with an object-oriented Matplotlib plot. The final balance can vary greatly; a single path can end very high or very low, so happiness depends on the particular sequence of flips. Overall, years 10 to mid 20, I am not too happy because my account balance is very low. Moreover, starting with $!,000 at age 0 and ending with $200 at age 30, I lost over $800 which is not a good outcome of the simulation; I would have preferred to see my account balance grow over time.


```{python}
#| label: q3-single-simulation
#| echo: false

import numpy as np
import matplotlib.pyplot as plt

# Reproducibility
np.random.seed(123)

# Parameters (original game rules)
initial_balance = 1000.0
n_years = 30  # simulate 30 annual flips (e.g., age 25 to 55)
p_heads = 0.5

# Simulate coin flips: 1 = heads (+50%), 0 = tails (-40%)
flips = np.random.binomial(n=1, p=p_heads, size=n_years)

# Evolve balance multiplicatively
balances = [initial_balance]
for flip in flips:
    if flip == 1:
        balances.append(balances[-1] * 1.5)
    else:
        balances.append(balances[-1] * 0.6)

# Create time index (years 0..n_years)
years = np.arange(n_years + 1)

# OO Matplotlib plot
fig, ax = plt.subplots(figsize=(9, 5))
ax.plot(years, balances, color='steelblue', linewidth=2, marker='o', markersize=4)
ax.set_title('Single Simulation: Account Balance Over Time (Original Game)', fontsize=13, fontweight='bold')
ax.set_xlabel('Year', fontsize=11)
ax.set_ylabel('Account Balance ($)', fontsize=11)
ax.grid(True, alpha=0.3)

# Format y-axis as currency
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

print(f"Final balance after {n_years} years: ${balances[-1]:,.2f}")
```

### Questions to Answer for 85% Grade on Challenge

4. **Multiple Simulations:** Run 100 simulations modelling the dynamics of your account balance over time. Make an object-oriented matplotlib OR ggplot2 plot showing a probability distribution of the 100 simulatedaccount balance at age 55. Comment on the results, are you happy? Why or why not?

## Answer: Below are 100 simulations of the original game over 30 years (age 25 to 55) with a Matplotlib histogram showing the distribution of final balances. I did buckets for every $500 and for any value above $10,000, I placed it in that bucket. I am not very happy with the results because there is a 70% chance that my account balance by age 55 will be below the $1,000 threshold. Therefore, I am not a risky player so there is no point of me trying to play this game since most likely, I will end up losing money. There is a small chance to hit the lottery and end up with over $10,000, but that risk is not worth it statistically. 
```{python}
#| label: q4-multiple-simulations
#| echo: false

import numpy as np
import matplotlib.pyplot as plt

# Reproducibility
np.random.seed(456)

# Parameters (original game rules)
initial_balance = 1000.0
n_years = 30  # simulate 30 annual flips (age 25 to 55)
n_sims = 100
p_heads = 0.5

# Function to simulate one path
def simulate_one_path(initial, years):
    balance = initial
    for _ in range(years):
        flip = np.random.binomial(1, p_heads)
        if flip == 1:
            balance *= 1.5  # +50% on heads
        else:
            balance *= 0.6   # -40% on tails
    return balance

# Run 100 simulations
final_balances = [simulate_one_path(initial_balance, n_years) for _ in range(n_sims)]

# OO Matplotlib histogram with custom $500 buckets
fig, ax = plt.subplots(figsize=(14, 8))

# Create custom bins every $500, with $10,000+ as final bucket
min_balance = min(final_balances)
max_balance = max(final_balances)
custom_bins = list(range(0, 10001, 500))  # $0, $500, $1000, $1500, ..., $10000
if max_balance > 10000:
    custom_bins.append(max_balance)  # Add final bin for anything over $10,000

n, bins, patches = ax.hist(final_balances, bins=custom_bins, color='lightblue', alpha=0.7, edgecolor='black', linewidth=0.5)

# Color bars based on whether they're above or below $1,000
for i, (patch, bin_left, bin_right) in enumerate(zip(patches, bins[:-1], bins[1:])):
    if bin_right <= initial_balance:
        patch.set_facecolor('lightcoral')  # Red for below $1,000
    else:
        patch.set_facecolor('lightgreen')  # Green for above $1,000

# Add vertical line at $1,000
ax.axvline(initial_balance, color='red', linestyle='--', linewidth=3, label=f'$1,000 Threshold')

# Add probability text boxes
prob_above = np.mean(np.array(final_balances) > initial_balance)
prob_below = 1 - prob_above

ax.text(0.02, 0.98, f'Above $1,000: {prob_above:.1%}', transform=ax.transAxes, 
        fontsize=12, fontweight='bold', color='green',
        bbox=dict(boxstyle='round,pad=0.5', facecolor='lightgreen', alpha=0.8),
        verticalalignment='top')

ax.text(0.02, 0.88, f'Below $1,000: {prob_below:.1%}', transform=ax.transAxes, 
        fontsize=12, fontweight='bold', color='red',
        bbox=dict(boxstyle='round,pad=0.5', facecolor='lightcoral', alpha=0.8),
        verticalalignment='top')

ax.set_title('Distribution of Final Account Balances at Age 55\n100 Simulations - $500 Buckets (10K+ Grouped)', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Final Balance ($)', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
ax.legend()
ax.grid(True, alpha=0.3)

# Format x-axis as currency with $500 increments
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f'${x:,.0f}'))
ax.tick_params(axis='x', rotation=45)

# Set x-axis limits to focus on the main distribution
ax.set_xlim(0, 10500)

plt.tight_layout()
plt.show()

# Summary statistics
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
prob_above_initial = np.mean(np.array(final_balances) > initial_balance)
max_balance = np.max(final_balances)
min_balance = np.min(final_balances)

print(f"Summary Statistics (100 simulations):")
print(f"Mean final balance: ${mean_balance:,.2f}")
print(f"Median final balance: ${median_balance:,.2f}")
print(f"Probability above $1,000: {prob_above_initial:.3f}")
print(f"Maximum balance: ${max_balance:,.2f}")
print(f"Minimum balance: ${min_balance:,.2f}")
```

### Questions to Answer for 95% Grade on Challenge

5. **Probability Analysis:** Based on the 100 simulations above, what is the probability that your account balance will be greater than $1,000 at age 55?

## Answer: Based on the 100 simulations from Question 4, the probability of ending above $1,000 at age 55 is 30%. This means that the probability you end up with less than $1,000 will be 70% which is not a great outcome for the player.

```{python}
#| label: q5-probability-analysis
#| echo: false

# Use the same final_balances from Question 4 simulations
# (In practice, you'd use the results from the previous simulation)

# Re-run the same simulation for consistency
import numpy as np

# Reproducibility (same seed as Question 4)
np.random.seed(456)

# Parameters (same as Question 4)
initial_balance = 1000.0
n_years = 30
n_sims = 100
p_heads = 0.5

# Function to simulate one path (same as Question 4)
def simulate_one_path(initial, years):
    balance = initial
    for _ in range(years):
        flip = np.random.binomial(1, p_heads)
        if flip == 1:
            balance *= 1.5  # +50% on heads
        else:
            balance *= 0.6   # -40% on tails
    return balance

# Run 100 simulations (same as Question 4)
final_balances = [simulate_one_path(initial_balance, n_years) for _ in range(n_sims)]

# Calculate probability of ending above $1,000
prob_above_1000 = np.mean(np.array(final_balances) > 1000)
prob_below_1000 = 1 - prob_above_1000

# Count actual results
count_above_1000 = np.sum(np.array(final_balances) > 1000)
count_below_1000 = n_sims - count_above_1000

print(f"Results from 100 simulations:")
print(f"Simulations ending above $1,000: {count_above_1000}")
print(f"Simulations ending below $1,000: {count_below_1000}")
print(f"")
print(f"Probability of ending above $1,000: {prob_above_1000:.3f} ({prob_above_1000:.1%})")
print(f"Probability of ending below $1,000: {prob_below_1000:.3f} ({prob_below_1000:.1%})")
print(f"")
print(f"Answer: The probability that your account balance will be greater than $1,000 at age 55 is {prob_above_1000:.1%}")
```

### Questions to Answer for 100% Grade on Challenge

6. **Strategy Comparison:** Run 100 simulations for the modified game strategy (betting 50% of balance each round). What is the probability that your account balance will be greater than $10,000 at age 55? Is this probability higher or lower than the probability in the original game?

## Answer: Below are 100 simulations of the modified game strategy (betting 50% of balance each round) compared to the original game. The modified strategy shows different dynamics due to the fixed betting percentage. What I can see from the graph is that the probability that my account balance is greater than $10,000 is lower in the modified game than the original game. There is a 3% chance that I will end up with over $10,000 in original game compared to a 1% chance I will end up with over $10,000 in the modified game. However, if the threshold is $1,000, the probability is much higher in the modified game as we can see in the graph there is higher amount of clusters above $1,000 compared to the original game.

```{python}
#| label: q6-strategy-comparison
#| echo: false

import numpy as np
import matplotlib.pyplot as plt

# Reproducibility
np.random.seed(789)

# Parameters
initial_balance = 1000.0
n_years = 30
n_sims = 100
p_heads = 0.5

# Original game function (from Questions 4-5)
def simulate_original_game(initial, years):
    balance = initial
    for _ in range(years):
        flip = np.random.binomial(1, p_heads)
        if flip == 1:
            balance *= 1.5  # +50% on heads
        else:
            balance *= 0.6   # -40% on tails
    return balance

# Modified game function (betting 50% of balance each round)
def simulate_modified_game(initial, years):
    balance = initial
    for _ in range(years):
        flip = np.random.binomial(1, p_heads)
        bet_amount = balance * 0.5  # Bet exactly 50% of current balance
        
        if flip == 1:
            # Win: bet increases by 50%, so total balance = remaining 50% + bet*1.5
            balance = (balance - bet_amount) + (bet_amount * 1.5)
        else:
            # Lose: bet decreases by 40%, so total balance = remaining 50% + bet*0.6
            balance = (balance - bet_amount) + (bet_amount * 0.6)
    return balance

# Run simulations for both strategies
original_balances = [simulate_original_game(initial_balance, n_years) for _ in range(n_sims)]
modified_balances = [simulate_modified_game(initial_balance, n_years) for _ in range(n_sims)]

# Calculate probabilities
prob_original_above_10k = np.mean(np.array(original_balances) > 10000)
prob_modified_above_10k = np.mean(np.array(modified_balances) > 10000)

# Create comparison histogram
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 7))

# Original game histogram
ax1.hist(original_balances, bins=20, color='lightblue', alpha=0.7, edgecolor='black')
ax1.axvline(10000, color='red', linestyle='--', linewidth=2, label='$10,000 Threshold')
ax1.set_title('Original Game Strategy\n(Full Balance Multiplicative)', fontsize=12, fontweight='bold')
ax1.set_xlabel('Final Balance ($)', fontsize=11)
ax1.set_ylabel('Frequency', fontsize=11)
ax1.legend()
ax1.grid(True, alpha=0.3)
ax1.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f'${x:,.0f}'))

# Modified game histogram
ax2.hist(modified_balances, bins=20, color='lightgreen', alpha=0.7, edgecolor='black')
ax2.axvline(10000, color='red', linestyle='--', linewidth=2, label='$10,000 Threshold')
ax2.set_title('Modified Game Strategy\n(Betting 50% of Balance)', fontsize=12, fontweight='bold')
ax2.set_xlabel('Final Balance ($)', fontsize=11)
ax2.set_ylabel('Frequency', fontsize=11)
ax2.legend()
ax2.grid(True, alpha=0.3)
ax2.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Print results
print("Strategy Comparison Results:")
print(f"Original Game - Probability above $10,000: {prob_original_above_10k:.3f} ({prob_original_above_10k:.1%})")
print(f"Modified Game - Probability above $10,000: {prob_modified_above_10k:.3f} ({prob_modified_above_10k:.1%})")
print(f"")
print(f"Answer: The probability of ending above $10,000 is {prob_modified_above_10k:.1%} for the modified game.")
print(f"This is {'HIGHER' if prob_modified_above_10k > prob_original_above_10k else 'LOWER'} than the original game ({prob_original_above_10k:.1%}).")
```
